#!/usr/bin/env bash
# This script was generated by bashly 1.0.1 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
kbulk_usage() {
  if [[ -n $long_usage ]]; then
    printf "kbulk - A kafka tool to perform different bulk actions\n"
    echo

  else
    printf "kbulk - A kafka tool to perform different bulk actions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  kbulk COMMAND\n"
  printf "  kbulk [COMMAND] --help | -h\n"
  printf "  kbulk --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Bulk change a topic replication factor\n" "replicas"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
kbulk_replicas_usage() {
  if [[ -n $long_usage ]]; then
    printf "kbulk replicas - Bulk change a topic replication factor\n"
    echo

  else
    printf "kbulk replicas - Bulk change a topic replication factor\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  kbulk replicas TOPICS TARGET [OPTIONS]\n"
  printf "  kbulk replicas --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--brokers, -n ID"
    printf "    Comma separated list of broker nodes where to place the replicas instead of\n    choosing the nodes randomly\n"
    echo

    # :flag.usage
    printf "  %s\n" "--bootstrap, -b SERVER (required)"
    printf "    Kafka bootstrap server\n"
    echo

    # :flag.usage
    printf "  %s\n" "--config, -c PROPERTIES"
    printf "    Kafka client configuration file (a .properties file)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TOPICS"
    printf "    Text file with the list of topics to change\n"
    echo

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "    Target number of replicas. If --brokers is not specified, the replicas will\n    be placed in random nodes\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "KBULK_BOOTSTRAP"
    printf "    Set the Kafka bootstrap server to use\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  kbulk topics.txt 4 --bootstrap localhost:9092 --config client.properties\n"
    printf "  kbulk topics.txt 3 --bootstrap localhost:9092 --config client.properties\n  --brokers 1,2,3\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
	local color="$1"
	shift
	if [[ -z ${NO_COLOR+x} ]]; then
		printf "$color%b\e[0m\n" "$*"
	else
		printf "%b\n" "$*"
	fi
}

no_color() { NO_COLOR=1 print_in_color "\e[31m" "$*"; }
red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/utils.sh

# $1: condition to wait for
# $2: Waiting message
# $3: Completion message
# $4: Wait interval in secs
wait_completion() {
	sp='/-\|'
	time=$SECONDS
	while
		# a small trick to execute the commands in the background based on the interval passed
		res=""
		if (((SECONDS - time) == $4)); then
			exec 3< <(eval "$1" 2>/dev/null)
			res=$(cat <&3 2>/dev/null)
			time=$SECONDS
		fi

		[[ -z $res ]]
	do
		# a spinner to not clutter the screen.
		printf "\b\e[33m$2 [%.1s]\e[0m\r" "$sp"
		sleep 0.1
		sp=${sp#?}${sp%???}

	done

	green_bold "$3"
	green_bold "================\n"
}

# :command.command_functions
# :command.function
kbulk_replicas_command() {
  # src/replicas_command.sh
  # echo "# this file is located in 'src/replicas_command.sh'"
  # echo "# code for 'kbulk replicas' goes here"
  # echo "# you can edit it freely and regenerate (it will not be overwritten)"
  # inspect_args

  topic_list=$(cat ${args[topics]})
  target=${args[target]}
  bootstrap="--bootstrap-server ${args[--bootstrap]}"

  config=${args[--config]}
  if [[ $config ]]; then
  	config="--command-config ${args[--config]}"
  fi

  num_brokers=$(kafka-broker-api-versions ${bootstrap} ${config} | awk '/id/{print $1}' | wc -l)

  function random_replicas() {
  	# ok=0
  	# min=1
  	# max=$1
  	list=$1
  	start=$2

  	# We want to increase the replication factor. Generate random new replicas
  	if [[ $start -lt $target ]]; then
  		while [[ $start -ne $target ]]; do
  			# getting a random number between 1 and num_brokers
  			rnd=$(awk -v n=$num_brokers 'BEGIN{srand();print int(rand()*(n))+1 }')
  			# Check if the replica is the same as the one passed as parameter. Don't include it then
  			if [[ $(echo "$list" | grep -c "$rnd") -eq 0 ]]; then
  				# new=$(random_replicas $max "${2},$rnd")
  				list=$list,$rnd
  				# new_count=$((new_count++))
  				((start++))
  			fi
  		done
  	else
  		# We want to decrease the replication factor. Keep the first ones until target
  		leader=$3
  		if [[ $target -gt 1 ]]; then
  			list=$(echo $list | cut -d, -f1-$target)
  			# if the leader was removed, cut another replica and add it back
  			if [[ $(echo "$list" | grep -c "$leader") -eq 0 ]]; then
  				if [[ $target -gt 1 ]]; then
  					list=$leader,$(echo $list | cut -d, -f1-$((target - 1)))
  				fi
  			fi
  		else
  			list=$leader
  		fi
  	fi

  	echo "${list}"
  }

  no_color "Number of brokers: ${num_brokers}"
  for topic in $topic_list; do
  	out=$(kafka-topics ${bootstrap} ${config} --describe --topic ${topic} 2>/dev/null)
  	partition_count=$(echo "{$out}" | grep -o "PartitionCount: [0-9.]" | awk '{print $2}')
  	green "Changing replication factor for topic $(green_bold "${topic}") $(green "with PartitionCount: ${partition_count}")"

  	json_delim=""
  	# printf "{\"version\": 1,\"partitions\": [\n" >kbulk-replica-assignment.json
  	json_header="{\"version\": 1,\"partitions\": [\n"
  	# Empty the file for next iteration
  	cat /dev/null >kbulk-replica-assignment.json

  	echo "{$out}" | grep "Replicas:" | awk '{print $4,$6,$8}' | while read p l r; do
  		curr_num_replicas=$(echo "$r" | awk -F '[,]' '{print NF}')

  		no_color "Current number of replicas for partition ${p} (Leader: ${l}): ${curr_num_replicas}"
  		# If the partition has already $target number of replicas, skip it
  		if [[ $curr_num_replicas -eq $target ]]; then
  			cyan "\tSkipping partition ${p}: current number of replicas already matches the target"
  		else
  			# if [[ $curr_num_replicas -gt $target ]]; then
  			#     new_replicas=$(random_replicas "$r")
  			# fi
  			new_replicas=$(random_replicas "${r}" "${curr_num_replicas}" "${l}")
  			yellow "\tPartition ${p} new replica assignment: ${r} ==> ${new_replicas}"
  			printf "${json_header}" >>kbulk-replica-assignment.json
  			printf "${json_delim}{\"topic\": \"${topic}\", \"partition\": ${p}, \"replicas\": [${new_replicas}]}" >>kbulk-replica-assignment.json
  			json_delim=",\n"
  			json_header=""
  			# if ((p + 1 == partition_count)); then json_delim=""; fi
  		fi

  	done

  	if grep -q . kbulk-replica-assignment.json; then
  		printf "\n]}" >>kbulk-replica-assignment.json
  		yellow "Executing the replica assignment for topic ${topic}.\nThis can take a while if your topic has a lot of data\n"

  		kafka-reassign-partitions ${bootstrap} ${config} --reassignment-json-file kbulk-replica-assignment.json --execute &>/dev/null

  		cond="kafka-reassign-partitions ${bootstrap} ${config} --reassignment-json-file replica-assignment.json --verify | grep -io \"complete\""
  		wait_completion "$cond" "Waiting for reasignment to complete." "Reassignment complete for Topic: ${topic}     " 2
  	else
  		cyan "Skipping topic $(cyan_bold "${topic}")$(cyan ": All partitions have replicas matching the target")"
  		cyan_bold "================\n"
  	fi

  done

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        kbulk_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    replicas | r)
      action="replicas"
      shift
      kbulk_replicas_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      kbulk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
kbulk_replicas_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        kbulk_replicas_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter

  # :command.command_filter
  action="replicas"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --brokers | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--brokers']="$2"
          shift
          shift
        else
          printf "%s\n" "--brokers requires an argument: --brokers, -n ID" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --bootstrap | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--bootstrap']="$2"
          shift
          shift
        else
          printf "%s\n" "--bootstrap requires an argument: --bootstrap, -b SERVER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c PROPERTIES" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['topics']+x} ]]; then

          args['topics']=$1
          shift
        elif [[ -z ${args['target']+x} ]]; then

          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['topics']+x} ]]; then
    printf "missing required argument: TOPICS\nusage: kbulk replicas TOPICS TARGET [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['target']+x} ]]; then
    printf "missing required argument: TARGET\nusage: kbulk replicas TOPICS TARGET [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--bootstrap']+x} ]]; then
    printf "missing required flag: --bootstrap, -b SERVER\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "replicas")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        kbulk_replicas_usage
      else
        kbulk_replicas_command
      fi
      ;;

  esac
}

initialize
run "$@"
